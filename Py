def encrypt(plain_text, key, key_size):
    n_blocks = len(plain_text) // 16

    n_rounds = {128: 10, 192: 12, 256: 14}[key_size]

    w = key_expansion(key, key_size)

    state = [[plain_text[b*4 + r] for r in range(4)] for b in range(n_blocks)]

    add_round_key(state, w[:4])

    for round in range(1, n_rounds):
        sub_bytes(state)
        shift_rows(state)
        mix_columns(state)
        add_round_key(state, w[round*4:(round+1)*4])

    sub_bytes(state)
    shift_rows(state)
    add_round_key(state, w[n_rounds*4:(n_rounds+1)*4])

    cipher_text = b"".join(bytes(state[b][r] for b in range(n_blocks) for r in range(4)))

    return cipher_text

def mix_columns(state):
    def mix_column(column):
        a = column[0]
        b = column[1]
        c = column[2]
        d = column[3]

        column[0] = gf_mul(a,2) ^ gf_mul(b,3) ^ gf_mul(c,1) ^ gf_mul(d,1)
        column[1] = gf_mul(a,1) ^ gf_mul(b,2) ^ gf_mul(c,3) ^ gf_mul(d,1)
        column[2] = gf_mul(a,1) ^ gf_mul(b,1) ^ gf_mul(c,2) ^ gf_mul(d,3)
        column[3] = gf_mul(a,3) ^ gf_mul(b,1) ^ gf_mul(c,1) ^ gf_mul(d,2)

        return column

    def gf_mul(a,b):
        p = 0
        hi_bit_set = False
        for counter in range(8):
            if b & 1:
                p ^= a
            hi_bit_set = a & 0x80
            a <<= 1
            if hi_bit_set:
                a ^= 0x1b
            b >>= 1

        return p % 256

    return [mix_column(column) for column in state]

def key_expansion(key, key_size):
    n_words = {128: 4, 192: 6, 256: 8}[key_size]
    n_rounds = {128: 10, 192: 12, 256: 14}[key_size]

    w = []

    for i in range(n_words):
        w.append([key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]])

    for i in range(n_words,n_rounds*4):
        temp = w[i-1].copy()
        if i % n_words == 0:
            temp.append(temp.pop(0))
            temp = [s_box[b] for b in temp]
            temp[0] ^= r_con[i//n_words]
        elif n_words > 6 and i % n_words == 4:
            temp = [s_box[b] for b in temp]
        w_i = [w[i-n_words][j] ^ temp[j] for j in range(4)]
        w.append([w_i[j] ^ w[i-n_words][j] for j in range(4)])

    return w

def add_round_key(state,key_schedule):
    for i in range(4):
        for j in range(4):
            state[i][j] ^= key_schedule[i][j]

def sub_bytes(state):
    for i in range(4):
        for j in range(4):
            state[i][j] = s_box[state[i][j]]

def shift_rows(state):
    state[1] = state[1][1:] + state[1][:1]
    state[2] = state[2][2:] + state[2][:2]
    state[3] = state[3][3:] + state[3][:3]

plain_text = b'\x00\x11\x22\x33\x44\x55\x66\x77\x88\x99\xaa\xbb\xcc\xdd\xee\xff'
key = b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17'
key_size = 192

cipher_text = encrypt(plain_text, key, key_size)

print("Cipher-text:", cipher_text.hex())
